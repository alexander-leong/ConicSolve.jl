var documenterSearchIndex = {"docs":
[{"location":"examples/denoise.html#Rank-Minimization","page":"Rank Minimization","title":"Rank Minimization","text":"","category":"section"},{"location":"examples/denoise.html#Introduction","page":"Rank Minimization","title":"Introduction","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Here is an example of solving the rank minimization problem with an additional nonnegative constraint","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"beginaligned\ntextminimizeqquad \nrankhspace01cmX \ntextsubject toqquad \nmathcalA(X) = b \n X succeq 0 \n X_ij = 0\nendaligned","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"see Recht, Fazel, Parrilo, 2010, Guaranteed Minimum-Rank Solutions of Linear Matrix Equations via Nuclear Norm Minimization for more details.","category":"page"},{"location":"examples/denoise.html#How-to-run-the-example","page":"Rank Minimization","title":"How to run the example","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"julia> ]\npkg> activate .\npkg> add ColorTypes\npkg> add ImageFiltering\npkg> add TestImages\n\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Run the example from the command line","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"julia example.jl","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Check the output from the console, you should see something like the following:","category":"page"},{"location":"examples/denoise.html#Explanation","page":"Rank Minimization","title":"Explanation","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"The image denoising example is an example application for solving a rank minimization problem. An image can be represented as a matrix. Here we're just going to take a patch of the image so our optimization problem doesn't get to unwieldy.","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"(Image: Original Image Patch)","category":"page"},{"location":"examples/denoise.html#Data-Acquisition","page":"Rank Minimization","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"The image is usually corrupted by some noise. In this example we purposely corrupt this image using salt-pepper noise. To determine which pixels are noisy we'll pass the image through a Laplacian distribution filter. By some threshold will determine which noise pixels to recover. This is what preprocess_data() does which will return a matrix img containing the loaded image and noise, the image mask where a value of 1 represents a noise pixel.","category":"page"},{"location":"examples/denoise.html#Solve-the-problem","page":"Rank Minimization","title":"Solve the problem","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"We're going to attempt to recover the missing data by denoising the image through rank minimization by creating an SDP model, see Using an SDP Model;","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"(i) We create a ConeQP object that represents the rank minimization problem to solve cone_qp = denoise_image(img, noise).","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"(ii) We pass the ConeQP object to the solver solver = Solver(cone_qp).","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"(iii) Then when we're ready we call run_solver passing the solver object run_solver(solver)`.","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"(iv) We can access the solution by accessing the primal solution from the solver x = get_solution(solver).","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"(v) However because x is the lower triangular part of the SDP matrix we need to index into the matrix to get back our image. This is easily done by calling the function like so output_img = get_X1(sdp, x).","category":"page"},{"location":"examples/denoise.html#Get-the-solution","page":"Rank Minimization","title":"Get the solution","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"How do we know we solved the problem? Well, inspecting the output we observe a couple of things:","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"We obtain a duality gap of zero (or close to zero), this suggests that the solution we obtained is optimal.\nThe x residual r_x, y residual r_y, z residual r_z are close to zero, this means we satisfied the primal and dual feasibility conditions.\nThe residuals, duality gap and objective values do not change much after successive iterations.","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Once primal feasibility is achieved in this particular example, we ensure that pixel values are nonnegative x = 0 and the non noise pixels are preserved Ax = b.","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"After 50 or so iterations, we get a better reconstruction of the image (Image: Reconstructed Image Patch)","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Further iterations should result in greater noise reduction.","category":"page"},{"location":"examples/denoise.html#Further-Comments","page":"Rank Minimization","title":"Further Comments","text":"","category":"section"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"Many optimization problems are not easy to solve and solvers including this one can run into numerical stability and performance issues. It is worthwhile exploring different parameter settings and reformulating the problem being solved in the event that these become issues.","category":"page"},{"location":"examples/denoise.html","page":"Rank Minimization","title":"Rank Minimization","text":"NOTE: We should bound 0 = x = 1 since pixel values shouldn't be larger than one but leave this as an exercise to the reader.","category":"page"},{"location":"examples/beamforming.html#Phased-Array-Diagram-Matching","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"","category":"section"},{"location":"examples/beamforming.html#Introduction","page":"Phased Array Diagram Matching","title":"Introduction","text":"","category":"section"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"A common problem in phased array beamforming applications is setting the weights (magnitude and phase) of each antenna to produce the desired diagram, radiation pattern of the array. If we make some simplifying assumptions, i.e. a planar antenna array, finding the weights can be expressed as a Conic LP problem, cf. Ben-Tal, Nemirovski, 2001, Lectures on Modern Convex Optimization Consider the optimization problem below, in this case we'll assume a given direction δ.","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"beginaligned\nundersetz_1z_N in mathbbCminimizeqquad \nZ_*(delta) - sum_j=1^Nz_jZ_j(delta)\nendaligned","category":"page"},{"location":"examples/beamforming.html#How-to-run-the-example","page":"Phased Array Diagram Matching","title":"How to run the example","text":"","category":"section"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"Ensure that you have ConicSolve installed. This can be installed as follows:","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"julia> ]\npkg> activate .\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"Run the example from the command line","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"julia example.jl","category":"page"},{"location":"examples/beamforming.html#Explanation","page":"Phased Array Diagram Matching","title":"Explanation","text":"","category":"section"},{"location":"examples/beamforming.html#Data-Acquisition","page":"Phased Array Diagram Matching","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"This is a simple toy problem setup. No data has been imported in this example.","category":"page"},{"location":"examples/beamforming.html#Solve-the-problem","page":"Phased Array Diagram Matching","title":"Solve the problem","text":"","category":"section"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"(i) We create a ConeQP object that represents the LP problem to solve cone_qp = get_qp(diagrams, target).","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"(ii) We pass the ConeQP object to the solver solver = Solver(cone_qp).","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"(iii) Then when we're ready we call run_solver passing the solver object run_solver(solver)`.","category":"page"},{"location":"examples/beamforming.html","page":"Phased Array Diagram Matching","title":"Phased Array Diagram Matching","text":"(iv) We can access the solution by accessing the primal solution from the solver x = get_solution(solver).","category":"page"},{"location":"examples/beamforming.html#Get-the-solution","page":"Phased Array Diagram Matching","title":"Get the solution","text":"","category":"section"},{"location":"examples/beamforming.html#Further-Comments","page":"Phased Array Diagram Matching","title":"Further Comments","text":"","category":"section"},{"location":"examples/trajectory_optimization.html#Trajectory-Optimization","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"","category":"section"},{"location":"examples/trajectory_optimization.html#Introduction","page":"Trajectory Optimization","title":"Introduction","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"Optimizing a trajectory is a typical problem in motion planning applications such as robotics. Representing a trajectory using polynomials allows one to express an optimization problem solved using sum-of-squares programming. Since a trajectory in this example uses univariate polynomials, a sum-of-squares optimization problem will be equivalent to solving a semidefinite program which we know how to solve, cf. Blekherman, Parrilo, Thomas, Semidefinite Optimization and Convex Algebraic Geometry.","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"The optimization problem to be solved will be mathematically expressed as follows:","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"beginaligned\ntextminimizeqquad \np^(t) \ntextsubject toqquad \np(t) text is SOS \np(0) = 0 \np(1) = 5 \np^(0) le 12 \np^(1) le 25\nendaligned","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"where p(t) = a_nt^n + a_n-1t^n-1 +  + a_1t^1 + a_0","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"In other words, we want to minimize the jerk (third derivative of position) such that the square of the coefficients are SOS and the initial position, final position, initial velocity and final velocity are given.","category":"page"},{"location":"examples/trajectory_optimization.html#How-to-run-the-example","page":"Trajectory Optimization","title":"How to run the example","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"julia> ]\npkg> activate .\npkg> add Polynomials\n\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"Run the example from the command line","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"julia example.jl","category":"page"},{"location":"examples/trajectory_optimization.html#Explanation","page":"Trajectory Optimization","title":"Explanation","text":"","category":"section"},{"location":"examples/trajectory_optimization.html#Data-Acquisition","page":"Trajectory Optimization","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"This is a simple toy problem setup. No data has been imported in this example.","category":"page"},{"location":"examples/trajectory_optimization.html#Solve-the-problem","page":"Trajectory Optimization","title":"Solve the problem","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(i) Create a fourth order polynomial with all coefficients set to 1 like so:","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"s = Polynomial([1, 1, 1, 1, 1], :t)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(ii) Create an SOS object and set a diagonal constraint on the Q matrix to readily resolve the coefficients of the fourth order polynomial","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"sos = SOS(s)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(iii) Set any other constraints, in this example, the initial position (to 0 at t = 0), final position (to 5 at t = 1), initial velocity (<= 1.2 at t = 0) and final velocity (<= 2.5 at t = 1)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"v_sos = derivative(s)\np = evaluate_monomials(s, 0)\nadd_polynomial_equality_constraint(sos, 0, p)\np = evaluate_monomials(s, 1)\nadd_polynomial_equality_constraint(sos, 5, p)\np = evaluate_monomials(v_sos, 0)\nadd_polynomial_inequality_constraint(sos, 1.2, p)\np = evaluate_monomials(v_sos, 1)\nadd_polynomial_inequality_constraint(sos, 2.5, p)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(iv) Set the objective by setting the vector c","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"c = zeros(size(sos.A)[2])\nc[1] = 1\nset_objective(sos, c)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(v) Get QP and solve","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"cone_qp = get_qp(sos)\nsolver = Solver(cone_qp)\n`run_solver`(solver)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(vi) Get solution from solver, i.e. values of Q","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"x = get_solution(solver)","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"(vii) Reconstruct polynomial (see below)","category":"page"},{"location":"examples/trajectory_optimization.html#Get-the-solution","page":"Trajectory Optimization","title":"Get the solution","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"The solution is given by the value of the coefficients for each of the Q values that constitute the SOS decomposition. Therefore to recover the coefficients of the monomial terms of the polynomial of interest is just to sum the coefficients of the same order. i.e.","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"beginalign*\na_0 = Q_55 \na_1 = Q_54 + Q_45 \na_2 = Q_44 + Q_53 + Q_35 \na_3 = Q_43 + Q_52 + Q_34 + Q_25\nendalign*","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"for a 4th order polynomial with the following quadratic form","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"p(t) = beginbmatrix t^4  t^3  t^2  t^1  1 endbmatrix\nbeginbmatrix\nQ_11  Q_12  Q_13  Q_14  Q_15 \nQ_21  Q_22  Q_23  Q_24  Q_25 \nQ_31  Q_32  Q_33  Q_34  Q_35 \nQ_41  Q_42  Q_43  Q_44  Q_45 \nQ_51  Q_52  Q_53  Q_54  Q_55\nendbmatrix\nbeginbmatrix t^4  t^3  t^2  t^1  1 endbmatrix","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"which expands to:","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"p(t) = a_0 + a_1*t + a_2*t^2 + a_3*t^3 + a_4*t^4","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"In using a higher degree polynomial we're more likely to find that it belongs to SOS.","category":"page"},{"location":"examples/trajectory_optimization.html#Further-Comments","page":"Trajectory Optimization","title":"Further Comments","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"We can impose further constraints such as polyhedral constraints for collision avoidance (see MotionPlanningOptimization.jl).","category":"page"},{"location":"functions.html","page":"API Reference","title":"API Reference","text":"CurrentModule = ConicSolve\nend","category":"page"},{"location":"functions.html#Cones","page":"API Reference","title":"Cones","text":"","category":"section"},{"location":"functions.html","page":"API Reference","title":"API Reference","text":"Modules = [ConicSolve]\nOrder = [:type, :function]\nPages = [\"nonneg.jl\", \"psdcone.jl\", \"soc.jl\"]","category":"page"},{"location":"functions.html#ConicSolve.NonNegativeOrthant","page":"API Reference","title":"ConicSolve.NonNegativeOrthant","text":"NonNegativeOrthant\n\nRepresents a nonnegative p-vector conic constraint.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.PSDCone","page":"API Reference","title":"ConicSolve.PSDCone","text":"PSDCone\n\nRepresents a positive semidefinite cone constraint.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.SecondOrderCone","page":"API Reference","title":"ConicSolve.SecondOrderCone","text":"SecondOrderCone\n\nRepresents a second order cone constraint.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#SDP","page":"API Reference","title":"SDP","text":"","category":"section"},{"location":"functions.html","page":"API Reference","title":"API Reference","text":"Modules = [ConicSolve]\nOrder = [:type, :function]\nPages = [\"sdp.jl\"]","category":"page"},{"location":"functions.html#ConicSolve.SDP","page":"API Reference","title":"ConicSolve.SDP","text":"SDP\n\nRepresents a Semidefinite Program (SDP). \ni.e. An optimization of the form\n\nbeginaligned\ntextminimizeqquad \nc^Tx \ntextsubject toqquad \nAx = b \n x succeq 0\nendaligned\n\n\nNOTE: Linear Matrix Inequalities not supported yet.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.SDP-Tuple{Any}","page":"API Reference","title":"ConicSolve.SDP","text":"SDP(X_1)\n\nConstructs an SDP optimization problem. \nNOTE: only elements of X_1 can be set for now. \nThe SDP matrix is given by\n\nX = beginbmatrix\n    X_2   X_1 \n    X_1  X_4\nendbmatrix\n\nParameters:\n\nX_1: The block matrix X_1 of the SDP matrix X\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_X1-Tuple{SDP, Any}","page":"API Reference","title":"ConicSolve.get_X1","text":"get_X1(sdp, x)\n\nReturns the values of X1 in the SDP matrix\n\nX = beginbmatrix\n    X_2  X_1^T \n    X_1  X_4\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_off_diag_nonnegative_constraint-Tuple{Any}","page":"API Reference","title":"ConicSolve.get_off_diag_nonnegative_constraint","text":"get_off_diag_nonnegative_constraint(A)\n\nSet a nonnegative constraint on the off diagonal entries of the SDP matrix.\n\nOutput\n\nThe matrix G to pass as argument to ConeQP.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_trace-Tuple{SDP}","page":"API Reference","title":"ConicSolve.get_trace","text":"get_trace(sdp)\n\nUsed to express the trace of the decision variable X in the objective function.\n\nOutput\n\nThe vector c to pass as argument to ConeQP.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.sdp_to_qp-Tuple{SDP}","page":"API Reference","title":"ConicSolve.sdp_to_qp","text":"sdp_to_qp(sdp)\n\nGet the Cone QP object representing the SDP problem\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_b_from_data-Tuple{SDP, Any}","page":"API Reference","title":"ConicSolve.set_b_from_data","text":"set_b_from_data(sdp, data)\n\nSet the values of the vector b in ConeQP based on the data matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_nonnegative_constraint-Tuple{SDP}","page":"API Reference","title":"ConicSolve.set_nonnegative_constraint","text":"set_nonnegative_constraint(sdp)\n\nImpose a nonnegative constraint on all values of the SDP matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_objective-Tuple{SDP, Any}","page":"API Reference","title":"ConicSolve.set_objective","text":"set_objective(sdp, c)\n\nSet the objective function of the SDP, which is the function langle c x rangle\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_off_diag_constraint-Tuple{SDP, Any, Any}","page":"API Reference","title":"ConicSolve.set_off_diag_constraint","text":"set_off_diag_constraint(sdp, data, mask)\n\nSet the off diagonal entries in the SDP matrix. i.e. [Y data; data' Z] The mask is a boolean matrix that corresponds to which elements of the data matrix to keep.\n\nOutput\n\nThe precomputed matrices A, G and the vector b to pass as arguments to ConeQP.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_values-Tuple{SDP, Any}","page":"API Reference","title":"ConicSolve.set_values","text":"set_values(sdp, mask)\n\nSet linear equalities of the SDP constraints where values of the SDP matrix X are determined by X_1 and the mask.\n\nif mask[i, j]\n    X_1[i, j] = X_1[i, j]\nend\n\n\n\n\n\n","category":"method"},{"location":"functions.html#SOS","page":"API Reference","title":"SOS","text":"","category":"section"},{"location":"functions.html","page":"API Reference","title":"API Reference","text":"Modules = [ConicSolve]\nOrder = [:type, :function]\nPages = [\"sos.jl\"]","category":"page"},{"location":"functions.html#ConicSolve.SOS","page":"API Reference","title":"ConicSolve.SOS","text":"SOS\n\nRepresents a Sum of Squares Optimization (SOS) Program. \nThe univariate polynomial p(x) = a_nx^n + a_n-1x^n-1 +  + a_1x^1 + a_0 is represented in quadratic form as: p(x) = v^TQv where:\n\nv = beginbmatrix\n    x^n  x^n-1    x^1  1\nendbmatrix\n\nMultivariate polynomials and other monomial basis are not supported at this stage.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.SOS-Tuple{Any}","page":"API Reference","title":"ConicSolve.SOS","text":"SOS(n)\n\nConstructs an SOS optimization problem. \n\n\nParameters:\n\nn: The order of the polynomial\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.add_polynomial_equality_constraint-Tuple{SOS, Any, Any}","page":"API Reference","title":"ConicSolve.add_polynomial_equality_constraint","text":"add_polynomial_equality_constraint(sos, b, p)\n\nSet an equality constraint on the polynomial to equal the value b.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.add_polynomial_inequality_constraint-Tuple{SOS, Any, Any}","page":"API Reference","title":"ConicSolve.add_polynomial_inequality_constraint","text":"add_polynomial_inequality_constraint(sos, h, p)\n\nSet an inequality constraint on the polynomial to equal the value h.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_objective-Tuple{SOS, Any, Any}","page":"API Reference","title":"ConicSolve.set_objective","text":"set_objective(sos, P, c)\n\nSet the objective function of the SOS\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.set_objective-Tuple{SOS, Any}","page":"API Reference","title":"ConicSolve.set_objective","text":"set_objective(sos, c)\n\nSet the objective function of the SOS, which is the function langle c x rangle\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.sos_to_qp-Tuple{SOS}","page":"API Reference","title":"ConicSolve.sos_to_qp","text":"sos_to_qp(sos)\n\nGet the Cone QP object representing the SOS optimization problem\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Solver","page":"API Reference","title":"Solver","text":"","category":"section"},{"location":"functions.html","page":"API Reference","title":"API Reference","text":"Modules = [ConicSolve]\nOrder = [:type, :function]\nPages = [\"qrchol.jl\", \"solver.jl\"]","category":"page"},{"location":"functions.html#ConicSolve.qr_chol_solve","page":"API Reference","title":"ConicSolve.qr_chol_solve","text":"qr_chol_solve(device, kktsystem, b_x, b_y, b_z, check)\n\nCalculates the vectors x and y (if linear equality constraints present) by solving the KKT system of linear equations where the KKT matrix is given by kktsystem, K and b_x (i.e. b_x), b_z (i.e. W^-Tb_z) are vectors and b_y (i.e. b_y, if linear equality constraints present).\n\nParameters\n\ndevice: CPU or GPU\nkktsystem: KKTSystem object\nb_x: The x component of the vector b\nb_y: The y component of the vector b\nb_z: The z component of the vector b\ncheck: true or false depending on whether matrix decompositions are valid\n\nOutput\n\nThe KKT solution vector [x; y; 0].\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ConicSolve.ConeQP","page":"API Reference","title":"ConicSolve.ConeQP","text":"ConeQP\n\nRepresents a Conic Quadratic Program.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.KKTSystem","page":"API Reference","title":"ConicSolve.KKTSystem","text":"KKTSystem\n\nThe KKT System solved by the KKT solver. In the absence of linear equalities, the system solved is:\n\nK = beginbmatrix\n    P   G^T   \n    G   -W^TW \nendbmatrix\n\nIn the presence of linear equalities, the system solved is:\n\nK = beginbmatrix\n    P   A^T    G^T   \n    A   0      0     \n    G   0      -W^TW \nendbmatrix\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.Solver","page":"API Reference","title":"ConicSolve.Solver","text":"Solver\n\nRepresents an Interior Point Method solver for solving Conic Quadratic Programs. All parameters are optional except program.\n\nParameters:\n\ncb_after_iteration: Callback function of the form: function cb(solver::Solver) end\ncb_before_iteration: Callback function of the form: function cb(solver::Solver) end\ndevice: CPU or GPU\nprogram: The Cone QP to solve\nkktsolver: The object to represent the KKT solver used to solve the KKT system. The kktsolve argument will construct the appropriate KKTSolver object. Possible values for kktsolve are conjgrad, minres and qrchol. qrchol is the default.\nlimit_obj: The minimum/maximum objective value the solver will terminate\nlimit_soln: The 2-norm difference between the current and previous estimates\nmax_iterations: The maximum number of iterations before the solver terminates\nnum_threads: The number of threads used on the CPU to perform certain BLAS and parallelized operations\ntime_limit_sec: The maximum number of seconds elapsed before the solver terminates after the current iteration\ntol_gap_abs: The absolute gap tolerance\ntol_gap_rel: The relative gap tolerance\ntol_optimality: The absolute tolerance for satisfying the optimality conditions\nη: Optimization parameter typically set to zero or σ, default is 0.0. Set η as nothing to set to σ.\nγ: Mehrotra correction parameter set to γ ∈ [0, 1], default is 1.0\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ConicSolve.get_objective-Union{Tuple{U}, Tuple{T}, Tuple{Union{Nothing, AbstractArray{Float64}}, AbstractArray{U}, AbstractArray{T}}} where {T<:Number, U<:Number}","page":"API Reference","title":"ConicSolve.get_objective","text":"get_objective(P, c, x)\n\nGet the current objective value to the conic quadratic program x^TPx + c^Tx\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_solution-Tuple{Solver}","page":"API Reference","title":"ConicSolve.get_solution","text":"get_solution(solver)\n\nGet the solution to the optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_solver_status-Tuple{Solver}","page":"API Reference","title":"ConicSolve.get_solver_status","text":"get_solver_status(solver)\n\nReturns the object of type SolverStatus used by the solver.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.is_optimal-Tuple{Solver, Float64, Float64, Float64}","page":"API Reference","title":"ConicSolve.is_optimal","text":"is_optimal(solver, gap_atol, gap_rtol, tol)\n\nThe stopping criterion used to determine convergence. Convergence is based on the following criteria:\n\nresiduals close to zero (within tol)\nsolution is primal-dual feasible\nduality gap close to zero (within tol)\nminimal change in primal objective value\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.run_solver","page":"API Reference","title":"ConicSolve.run_solver","text":"run_solver(solver)\n\nExecutes the solver on the optimization problem.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#Helper-Methods","page":"API Reference","title":"Helper Methods","text":"","category":"section"},{"location":"functions.html","page":"API Reference","title":"API Reference","text":"Modules = [ConicSolve]\nOrder = [:type, :function]\nPages = [\"arrayutils.jl\", \"imageutils.jl\"]","category":"page"},{"location":"functions.html#ConicSolve.apply_cart_on_f-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"ConicSolve.apply_cart_on_f","text":"apply_cart_on_f(f, args...)\n\nOutput\n\nReturns an array of f(x...) passing each value x of the cartesian product args... i.e. example input\n\na = [0, 1]\nb = [3, 2]\nvals = apply_cart_on_f(f, a, b)\n\nyields vals = [f(0, 3), f(0, 2), f(1, 3), f(1, 2)]\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.dropzero_rows-Tuple{Any}","page":"API Reference","title":"ConicSolve.dropzero_rows","text":"dropzero_rows(X)\n\nRemoves row of zeros from a given matrix X.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_block_matrix-NTuple{5, Any}","page":"API Reference","title":"ConicSolve.get_block_matrix","text":"get_block_matrix(X, x_l, y_l, x_u, y_u)\n\nGet block matrix defined by the row and column range. \nx_l <= i <= x_u \ny_l <= j <= y_u\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_diagonal_idx-Tuple{Any}","page":"API Reference","title":"ConicSolve.get_diagonal_idx","text":"get_diagonal_idx(n)\n\nGet vectorized diagonal indices. For example, the following entries returned: idx = [1, 5, 8, 10] correspond to the matrix of n=4: [1 2 3 4; 2 5 6 7; 4 7 9 10]\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_mask-Tuple{Any, Any}","page":"API Reference","title":"ConicSolve.get_mask","text":"get_mask(cond, data)\n\nCreates a mask given a predicate function, cond against the data matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_off_diagonal_idx-Tuple{Any}","page":"API Reference","title":"ConicSolve.get_off_diagonal_idx","text":"get_off_diagonal_idx(n)\n\nGet vectorized lower triangular off diagonal indices. For example, the following entries returned: idx = [2, 3, 4, 6, 7, 9] correspond to the matrix of n=4: [1 2 3 4; 2 5 6 7; 3 6 8 9; 4 7 9 10]\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.get_triangular_idx-Tuple{Any, Any}","page":"API Reference","title":"ConicSolve.get_triangular_idx","text":"get_triangular_idx(A_idx, mask)\n\nGet vectorized lower triangular indices given a 2d mask.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.lower_triangular_from_2d_idx-Tuple{Any, Any}","page":"API Reference","title":"ConicSolve.lower_triangular_from_2d_idx","text":"lower_triangular_from_2d_idx(n, idx)\n\nConverts 2d index values of a square matrix of size n x n.\n\nOutput\n\nReturn the index values of a vectorized lower triangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.mat-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Number","page":"API Reference","title":"ConicSolve.mat","text":"mat(u)\n\nPerforms the inverse operation of vec(U), i.e. mat(vec(U)) = U\n\nOutput\n\nReturns a matrix representation of the vector u.\n\nbeginbmatrix\n    u_1             u_2sqrt2      u_3sqrt2    dots   u_nsqrt2     \n    u_2sqrt2   u_p+1              u_23sqrt2   dots   u_2p-1sqrt2  \n    vdots           vdots              vdots                     vdots             \n    u_psqrt2   u_2p-1sqrt2   u_d3sqrt2   dots   u_p(p+1)2\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ConicSolve.svec-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Number","page":"API Reference","title":"ConicSolve.svec","text":"svec(U)\n\nOutput\n\nReturns a vectorized representation of the square matrix U as (U_11 sqrt2U_21  sqrt2U_p1 U_22 sqrt2U_32  sqrt2U_p2  U_p-1p-1 sqrt2U_pp-1 U_pp)\n\n\n\n\n\n","category":"method"},{"location":"examples/maximum_flow.html#Maximum-Flow-Minimum-Cut","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"","category":"section"},{"location":"examples/maximum_flow.html#Introduction","page":"Maximum Flow Minimum Cut","title":"Introduction","text":"","category":"section"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"Max flow min cut problems have multidisciplinary applications and commonly discussed due to pedagogical purposes. The problem is to maximize the flow (or throughput) of some quantity such as network data from a given source node to a destination node subject to capacity constraints between the nodes in the graph. This problem is an LP problem which has a natural conic formulation.","category":"page"},{"location":"examples/maximum_flow.html#How-to-run-the-example","page":"Maximum Flow Minimum Cut","title":"How to run the example","text":"","category":"section"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"Ensure that you have ConicSolve installed. This can be installed as follows:","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"julia> ]\npkg> activate .\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"Run the example from the command line","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"julia example.jl","category":"page"},{"location":"examples/maximum_flow.html#Explanation","page":"Maximum Flow Minimum Cut","title":"Explanation","text":"","category":"section"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"Assume we have the network graph below: (Image: Network Flow)","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"The adjacency matrix can be formed from the non-zero entries in the matrix of maximum capacities between nodes, i.e.","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"G = beginbmatrix\n0  3  2  2  0  0  0  0 \n0  0  0  0  5  1  0  0 \n0  0  0  0  1  3  1  0 \n0  0  0  0  0  1  0  0 \n0  0  0  0  0  0  0  4 \n0  0  0  0  0  0  0  2 \n0  0  0  0  0  0  0  4 \n0  0  0  0  0  0  0  0\nendbmatrix","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"For example, the (1, 2) entry corresponds to a capacity of 3 and a minimum capacity of 2 from node 1 (row 1) to node 2 (column 2).","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"Similarly an adjacency matrix can be formed for the minimum capacities between nodes, i.e.","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"min_G = beginbmatrix\n0  2  2  2  0  0  0  0 \n0  0  0  0  2  0  0  0 \n0  0  0  0  0  2  0  0 \n0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0 \n0  0  2  0  0  0  0  0 \n0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0\nendbmatrix","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"We need to define the set of flow conservation constraints, i.e. the sum of the flows into a node must equal the sum of the flows out of a node except for the source node and destination node. The notation I_m-n will determine the variables concerned. E.g. the conservation of flow for node 2 can be expressed as:","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"I_1-2*x_1-2 = I_2-5*x_2-5 + I_2-6*x_2-6","category":"page"},{"location":"examples/maximum_flow.html#Data-Acquisition","page":"Maximum Flow Minimum Cut","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"This is a simple toy problem setup. No data has been imported in this example.","category":"page"},{"location":"examples/maximum_flow.html#Solve-the-problem","page":"Maximum Flow Minimum Cut","title":"Solve the problem","text":"","category":"section"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"(i) We create a ConeQP object that represents the LP problem to solve cone_qp = get_qp(G, min_G).","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"(ii) We pass the ConeQP object to the solver solver = Solver(cone_qp).","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"(iii) Then when we're ready we call run_solver passing the solver object run_solver(solver)`.","category":"page"},{"location":"examples/maximum_flow.html","page":"Maximum Flow Minimum Cut","title":"Maximum Flow Minimum Cut","text":"(iv) We can access the solution by accessing the primal solution from the solver x = get_solution(solver).","category":"page"},{"location":"examples/maximum_flow.html#Get-the-solution","page":"Maximum Flow Minimum Cut","title":"Get the solution","text":"","category":"section"},{"location":"examples/maximum_flow.html#Further-Comments","page":"Maximum Flow Minimum Cut","title":"Further Comments","text":"","category":"section"},{"location":"design.html#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design.html#Features","page":"Design","title":"Features","text":"","category":"section"},{"location":"design.html","page":"Design","title":"Design","text":"Solves LP (Linear Programming), QP (Quadratic Programming), SOCP (Second Order Cone Programming) and SDP (Semidefinite Programming) problems\nSupports Nonnegative Orthant, Second Order and Positive Semidefinite cone types\nMinimal project dependencies (mainly LAPACK)\nImplements common array manipulation operations to reduce complexity in defining optimization problems\nCan define Semidefinite and Sum of Squares problems with ease using predefined models\nModular (by design) so users can bring their own KKT (Karush Kuhn Tucker) solver to utilize sparsity patterns and problem structure for optimal solver performance\nOpen source (MIT License)\nSeveral scientific and engineering examples ready to be extended for real world application\nNative conic solver interface, reduce overhead associated with using dependencies when defining an optimization problem","category":"page"},{"location":"design.html#Components","page":"Design","title":"Components","text":"","category":"section"},{"location":"design.html","page":"Design","title":"Design","text":"All example applications extend from either the native or model based APIs. The rank minimization (matrix completion) example (for example) uses the SDP model and trajectory optimization example uses the SOS model.","category":"page"},{"location":"design.html","page":"Design","title":"Design","text":"You may need to install further dependencies to run the specific examples. This modular approach allows the optimization solver to be performant, extensible for future emerging applications and versatile so it is suitable for solving large-scale problems or real-time embedded problems for example.","category":"page"},{"location":"design.html","page":"Design","title":"Design","text":"The high-level component diagram (see below) can serve as a guide for users and developers working with the project codebase.","category":"page"},{"location":"design.html","page":"Design","title":"Design","text":"(Image: Component Diagram)","category":"page"},{"location":"examples/total_variation_reconstruction.html#Total-Variation-Reconstruction","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html#Introduction","page":"Total Variation Reconstruction","title":"Introduction","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"Problems in signal processing typically involve filtering, denoising and smoothing a signal. In this example we'll look at total variation reconstruction of a 1-D signal. We'll consider the optimization problem below:","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"beginaligned\ntextminimizeqquad  left lVert hatx-(x+v) right rVert _2 + lambda left lVert Dhatx right rVert _1\nendaligned","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"This is a multi criterion (bicriterion) problem since there are two variables we want to optimize against. All multi criterion problems require a tradeoff and the parameter lambda enables this. By increasing lambda we encourage a solution that aims for left lVert Dhatx right rVert _1 small. The converse is also true, reducing lambda will encourage left lVert hatx-(x+v) right rVert _2 small.","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"In this example, hatx is the decision variable and x+v is the 1-D input signal for some noise v which we want to denoise.","category":"page"},{"location":"examples/total_variation_reconstruction.html#How-to-run-the-example","page":"Total Variation Reconstruction","title":"How to run the example","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"julia> ]\npkg> activate .\n\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"Run the example from the command line","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"julia example.jl","category":"page"},{"location":"examples/total_variation_reconstruction.html#Explanation","page":"Total Variation Reconstruction","title":"Explanation","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"We can write the optimization problem in conic form as follows:","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"","category":"page"},{"location":"examples/total_variation_reconstruction.html#Data-Acquisition","page":"Total Variation Reconstruction","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"This is a simple toy problem setup. No data has been imported in this example.","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"x+v is white noise generated using Julia's default pseudo-random number generator.","category":"page"},{"location":"examples/total_variation_reconstruction.html#Solve-the-problem","page":"Total Variation Reconstruction","title":"Solve the problem","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html#Get-the-solution","page":"Total Variation Reconstruction","title":"Get the solution","text":"","category":"section"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"After reconstructing the signal we should get something like this.","category":"page"},{"location":"examples/total_variation_reconstruction.html","page":"Total Variation Reconstruction","title":"Total Variation Reconstruction","text":"(Image: Reconstructed Signal)","category":"page"},{"location":"examples/total_variation_reconstruction.html#Further-Comments","page":"Total Variation Reconstruction","title":"Further Comments","text":"","category":"section"},{"location":"examples/portfolio.html#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"examples/portfolio.html#Introduction","page":"Portfolio Optimization","title":"Introduction","text":"","category":"section"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"The portfolio optimization example as described in Boyd, Vandenberghe, 2009, Convex Optimization can be formulated as a Conic SOCP program as follows.","category":"page"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginaligned\ntextmaximizeqquad \nmathbbE(p)^Tx \ntextsubject toqquad \nmathbbE(p)^Tx + Phi^-1(beta)left lVert Sigma^12x right rVert _2 ge alpha \n x ge 0 \n textbf1^Tx = 1\nendaligned","category":"page"},{"location":"examples/portfolio.html#How-to-run-the-example","page":"Portfolio Optimization","title":"How to run the example","text":"","category":"section"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"julia> ]\npkg> activate .\npkg> add CSV\npkg> add DataFrames\npkg> add Distributions\n\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Run the example from the command line","category":"page"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"julia example.jl","category":"page"},{"location":"examples/portfolio.html#Explanation","page":"Portfolio Optimization","title":"Explanation","text":"","category":"section"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"The portfolio optimization example is an example for maximizing expected return given a set of stocks subject to some risk tolerance. A table of stock ticks can be found in portfolio.csv, i.e. the daily close price of seven random stocks.","category":"page"},{"location":"examples/portfolio.html#Data-Acquisition","page":"Portfolio Optimization","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"CSV.jl is used to load the file portfolio.csv into a DataFrame object (using DataFrames.jl). The data frame is then converted to a matrix for the solver.","category":"page"},{"location":"examples/portfolio.html#Solve-the-problem","page":"Portfolio Optimization","title":"Solve the problem","text":"","category":"section"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"The problem parameters are calculated using Distributions.jl and Statistics.jl to get the expected return and price change variance. The loss risk constraint contains two tuning parameters beta le 05 (based on the inv. cdf of the std. normal distribution) to control the level of risk and alpha, the loss amount for the level of risk.","category":"page"},{"location":"examples/portfolio.html#Get-the-solution","page":"Portfolio Optimization","title":"Get the solution","text":"","category":"section"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"For this problem setting the parameter eta to nothing (i.e. sigma) may give better results.","category":"page"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"The solution is x which can be obtained as below: x in 0 1 is the optimal weight of each stock in the portfolio.","category":"page"},{"location":"examples/portfolio.html","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"x = get_solution(solver)","category":"page"},{"location":"examples/quantum_separability.html#Quantum-Separability","page":"Quantum Separability","title":"Quantum Separability","text":"","category":"section"},{"location":"examples/quantum_separability.html#Introduction","page":"Quantum Separability","title":"Introduction","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"Detecting whether the Quantum state of a Quantum system is separable or not is a fundamental problem in Quantum information theory and applications.","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"In this example we'll look at a bipartite quantum state in a 2x2 Hilbert space. The same concepts apply when developing SDP formulations for 3x3 systems and so forth. Additional conditions for determining separability for the 3x3 case and beyond (referred to as a hierarchy) do apply. We proceed with an application of the DPS Doherty, Parrilo, Spedalieri hierarchy as follows.","category":"page"},{"location":"examples/quantum_separability.html#How-to-run-the-example","page":"Quantum Separability","title":"How to run the example","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"julia> ]\npkg> activate .\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/quantum_separability.html#Explanation","page":"Quantum Separability","title":"Explanation","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"The bases for a 2-dimensional Hilbert space such that they satisfy:","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"Trsigma_i^Xsigma_j^X = alpha_Xdelta_ij hspace1cm and hspace1cm Trsigma_i^X = delta_i1","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"for subsystem X is given by the Pauli matrices:","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"sigma_0 = beginbmatrix\n1alpha_X  0 \n0  1alpha_X \nendbmatrix\nhspace1cm\nsigma_1 = beginbmatrix\n0  1alpha_X \n1alpha_X  0 \nendbmatrix\nhspace1cm\nsigma_2 = beginbmatrix\n0  -ialpha_X \nialpha_X  0 \nendbmatrix\nhspace1cm\nsigma_3 = beginbmatrix\n1alpha_X  0 \n0  -1alpha_X \nendbmatrix","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"where alpha_X = 2.","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"The PPT extension tilderho can be written as a set of Linear Matrix Inequality (LMI) for an SDP.","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"G_0 = sum_j rho_1jsigma_1^A otimes sigma_j^B otimes sigma_1^A + sum_i=2 j=1 rho_ijsigma_i^A otimes sigma_j^B otimes sigma_1^A + sigma_1^A otimes sigma_j^B otimes sigma_i^A","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"G_iji = sigma_i^A otimes sigma_j^B otimes sigma_i^A hspace1cm i ge 2","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"G_ijk = (sigma_i^A otimes sigma_j^B otimes sigma_k^A + sigma_k^A otimes sigma_j^B otimes sigma_i^A) hspace1cm k gt i ge 2","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"where rho_ij is defined as","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"rho_ij = alpha_A^-1alpha_B^-1Trrhosigma_i^A otimes sigma_j^B","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"So in Conic form the G matrix can be written as","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"G = beginbmatrix\nsvec(G_0)  svec(G_iji)  svec(G_ijk)\nendbmatrix","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"The svec(G_iji) and svec(G_ijk) are hcat (horizontal concatenate) together with svec(G_0)","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"We must not forget the partial transposes of tilderho with respect to subsystem A, tilderho^T_A and subsystem B, tilderho^T_B. So once these are computed the final G matrix which we call F for lack of better notation can be written as:","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"F = beginbmatrix\nG \nG^T_A \nG^T_B endbmatrix","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"We now take F (as the variable G in code) to enforce the PSD condition for the SDP feasibility problem:","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"beginaligned\ntextminimizeqquad  0 \ntextsubject toqquad \nF succeq 0 \nendaligned","category":"page"},{"location":"examples/quantum_separability.html#Data-Acquisition","page":"Quantum Separability","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"This is a simple toy problem setup. No data has been imported in this example.","category":"page"},{"location":"examples/quantum_separability.html#Solve-the-problem","page":"Quantum Separability","title":"Solve the problem","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"(i) We create a ConeQP object that represents the SDP problem to solve cone_qp = get_qp().","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"(ii) We pass the ConeQP object to the solver solver = Solver(cone_qp).","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"(iii) Then when we're ready we call run_solver passing the solver object run_solver(solver)`.","category":"page"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"(iv) We can access the solution by accessing the primal solution from the solver x = get_solution(solver).","category":"page"},{"location":"examples/quantum_separability.html#Get-the-solution","page":"Quantum Separability","title":"Get the solution","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"For the given density matrix rho we see all residuals tend to zero suggesting that the quantum state is separable.","category":"page"},{"location":"examples/quantum_separability.html#Further-Comments","page":"Quantum Separability","title":"Further Comments","text":"","category":"section"},{"location":"examples/quantum_separability.html","page":"Quantum Separability","title":"Quantum Separability","text":"The DPS hierarchy is a complete set of criteria for determining separability of quantum states in a bipartite quantum system. The PSD condition is only one of the tests (not necessarily sufficient) and the reader should consult the DPS paper for more details. In any case if one of these tests fails, the quantum state is entangled. If the PSD condition fails for example, the SDP feasibility problem is unsolvable, the quantum state is entangled.","category":"page"},{"location":"examples/phase_cut.html#Phase-Retrieval","page":"Phase Retrieval","title":"Phase Retrieval","text":"","category":"section"},{"location":"examples/phase_cut.html#Introduction","page":"Phase Retrieval","title":"Introduction","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"PhaseCut is an algorithm for solving the phase retrieval problem that has applications in X-ray crystallography, transmission electron microscopy and coherent diffractive imaging for example.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"We'll consider the task of recovering the phase of a 1-D signal. The optimization problem being solved is written as:","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"beginaligned\ntextminimizeqquad  textbfTr(UM) \ntextsubject toqquad \ntextbfdiag(U) = textbf1\nU succeq 0\nendaligned","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"where U is the decision variable with respect to the positive semidefinite cone and M is defined as:","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"M = textbfdiag(b)(textbfI - AA^dagger)textbfdiag(b)","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"The matrix A is taken as the 1-D DFT matrix of size nxn where n is the length of the signal and A^dagger is the Moore Penrose Pseudoinverse of A.","category":"page"},{"location":"examples/phase_cut.html#How-to-run-the-example","page":"Phase Retrieval","title":"How to run the example","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"julia> ]\npkg> activate .\npkg> add FFTW\n\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"examples/phase_cut.html#Explanation","page":"Phase Retrieval","title":"Explanation","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"We can write the optimization problem in conic form as follows:","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"beginaligned\ntextminimizeqquad  textbfsvec(M)^Ttextbfsvec(U) \ntextsubject toqquad \nbeginbmatrix\ntextbfsvec(textbfdiag(1  0    0))^T \ntextbfsvec(textbfdiag(0  1    0))^T \nvdots \ntextbfsvec(textbfdiag(0  0    1))^T \nendbmatrix\nu = textbf1\nU succeq 0\nendaligned","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"and using the fact that textbfTr(MU) = textbfsvec(M)^Ttextbfsvec(U).","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"Since ConicSolve.jl is a real-numbered solver, the Hermitian matrix M can be encoded as a real symmetric matrix, i.e.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"beginbmatrix\ntextbfRe(M)  -textbfIm(M) \ntextbfIm(M)  textbfRe(M)\nendbmatrix","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"This example uses the \"multiple random illumination filters\" method for phase retrieval. In this case the matrix A consists of a stack of randomly generated circulant matrices defining each of the random illumination filters, i.e.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"A = beginbmatrix\nC_1 \nC_2 \nvdots \nC_m\nendbmatrix","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"where C_k is the k^th Circulant matrix of size n x n, n is the length of the signal being estimated.","category":"page"},{"location":"examples/phase_cut.html#Data-Acquisition","page":"Phase Retrieval","title":"Data Acquisition","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"This is a simple toy problem setup. No data has been imported in this example.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"A simple sine wave function has been used as the signal we want to reconstruct.","category":"page"},{"location":"examples/phase_cut.html#Solve-the-problem","page":"Phase Retrieval","title":"Solve the problem","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"(i) We create a ConeQP object that represents the SDP problem to solve cone_qp = get_qp().","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"(ii) We pass the ConeQP object to the solver solver = Solver(cone_qp).","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"(iii) Then when we're ready we call run_solver passing the solver object solver.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"(iv) We can access the solution by accessing the primal solution from the solver u = get_solution(solver).","category":"page"},{"location":"examples/phase_cut.html#Get-the-solution","page":"Phase Retrieval","title":"Get the solution","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"The output of get_solution is used by reconstruct_signal to evaluate the following expression giving the reconstructed signal.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"x = A^daggertextbfdiag(b)u","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"Since this problem is an SDP relaxation and we know that U should be rank one (or close to it), a good way to check the tightness of the relaxation is to check the eigenvalues of U.","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"If one of the eigenvalues is large and the rest are close to zero, we're good.","category":"page"},{"location":"examples/phase_cut.html#Further-Comments","page":"Phase Retrieval","title":"Further Comments","text":"","category":"section"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"The aim is to get the reconstructed signal as close to the original input signal (the sine wave) generated. One way to measure the accuracy of the reconstruction is the Mean Squared Error (MSE) given by","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"MSE = dfrac1nSigma_i=1^n(b - Ax)^2","category":"page"},{"location":"examples/phase_cut.html","page":"Phase Retrieval","title":"Phase Retrieval","text":"Sometimes the reconstruction may be poor because U is not close to rank one. We should notice the reconstruction of x improve by increasing the number of filters and sample points used over the signal.","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"<img src=\"./assets/logo.png\"/>","category":"page"},{"location":"index.html#Introduction","page":"Readme","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"ConicSolve.jl is a Primal-Dual Interior-Point method constrained optimization solver based on the paper Vandenberghe, 2010, The CVXOPT linear and quadratic cone program solvers. It can be used to solve several problem classes including LP (Linear Program), QP (Quadratic Program) and SDP (Semidefinite Program).","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"warning: Warning\nThis solver is experimental, APIs and implementation are subject to change without notice. The solver has not been rigorously tested, may contain bugs and numerical stability issues.","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"The solver requires that problems be expressed as a cone quadratic program (cone QP) i.e. in the form","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"beginaligned\ntextminimizeqquad \n(12)x^TPx + c^Tx \ntextsubject toqquad \nGx + s = h \n Ax = b \n s succeq 0\nendaligned","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"where P is a PSD (positive semidefinite) matrix, s is a generalized inequality with respect to a self-dual convex cone.","category":"page"},{"location":"index.html#Installation","page":"Readme","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"To use ConicSolve.jl, install Julia, then at the Julia REPL, type:","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"using Pkg\nPkg.add(\"ConicSolve\")\nusing ConicSolve","category":"page"},{"location":"index.html#GPU-Acceleration","page":"Readme","title":"GPU Acceleration","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"ConicSolve.jl uses CUDA.jl to accelerate matrix factorization methods for solving the KKT equations. Refer to CUDA.jl for additional installation requirements.","category":"page"},{"location":"index.html#How-to-use","page":"Readme","title":"How to use","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"There are two ways to construct an optimization problem in ConicSolve.jl","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"Using the Low Level API\nUsing models to precompute matrices before invoking the low level API","category":"page"},{"location":"index.html#Using-the-Low-Level-API","page":"Readme","title":"Using the Low Level API","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"julia> using ConicSolve\njulia> p_1 = 16 # for example, 16 x 16 SDP matrix\njulia> p_2 = 136 # for example, 136 elements (or 16 * 17 / 2) in lower triangular SDP matrix\njulia> A = [] # problem specific, replace with your values\njulia> G = [] # problem specific, replace with your values\njulia> P = [] # problem specific, replace with your values\njulia> b = [] # problem specific, replace with your values\njulia> c = [] # problem specific, replace with your values\njulia> h = [] # problem specific, replace with your values\njulia> cones::Vector{Cone} = []\njulia> push!(cones, PSDCone(p_1))\njulia> push!(cones, NonNegativeOrthant(p_2))\njulia> cone_qp = ConeQP(A, G, P, b, c, h, cones)\njulia> solver = Solver(cone_qp)\njulia> run_solver(solver)","category":"page"},{"location":"index.html#Using-an-SDP-Model","page":"Readme","title":"Using an SDP Model","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"julia> using ConicSolve\njulia> data = [] # your data here\njulia> mask = [] # your data here\njulia> sdp = SDP(data)\njulia> set_values(sdp, mask)\njulia> set_nonnegative_constraint(sdp)\njulia> c = get_trace(sdp)\njulia> set_objective(sdp, c)\njulia> qp = get_qp(sdp)\njulia> solver = Solver(qp)\njulia> run_solver(solver)","category":"page"},{"location":"index.html#Examples","page":"Readme","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"In the examples directory you will find several examples which gives an idea of how to use the API for this solver.","category":"page"},{"location":"index.html#How-to-cite","page":"Readme","title":"How to cite","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"@misc{Leong2025,\n    title = {ConicSolve: A constrained optimization solver for scientific advancement},\n    author = {Alexander Leong},\n    url = {http://localhost:8000/index.html}\n}","category":"page"},{"location":"index.html#Contributions","page":"Readme","title":"Contributions","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"This solver has been developed for the sole purpose of investigating new and existing applications for Interior Point based methods by creating a solver that has minimal project dependencies, is highly performant, general purpose, extensible and most importantly is free for public use.","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"This project is still a work in progress. Any contributions to add additional examples and use cases are welcome! Even if you can't contribute, please consider providing financial assistance if you have found this project useful in your work.","category":"page"},{"location":"index.html#Reference-Material","page":"Readme","title":"Reference Material","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"<a href=\"./assets/ConicSolve.pdf\">Project Poster","category":"page"},{"location":"index.html#License","page":"Readme","title":"License","text":"","category":"section"},{"location":"index.html","page":"Readme","title":"Readme","text":"MIT License","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"Copyright (c) 2025 Alexander Leong","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"index.html","page":"Readme","title":"Readme","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html#Running-the-image-denoising-example","page":"Tutorial","title":"Running the image denoising example","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Ensure that you have the necessary dependencies installed. These can be installed by executing the following commands:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia> ]\npkg> activate .\npkg> add ColorTypes\npkg> add ImageFiltering\npkg> add TestImages\n\npkg> add ConicSolve\njulia> exit()","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Run the example from the command line","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia example.jl","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Check the output from the console, you should see something like the following:","category":"page"},{"location":"tutorial.html#Explanation","page":"Tutorial","title":"Explanation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The image denoising example is an example application for solving a rank minimization problem. An image can be represented as a matrix. Here we're just going to take a patch of the image so our optimization problem doesn't get to unwieldy.","category":"page"},{"location":"tutorial.html#Data-Acquisition","page":"Tutorial","title":"Data Acquisition","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The image is usually corrupted by some noise. In this example we purposely corrupt this image using salt-pepper noise. To determine which pixels are noisy we'll pass the image through a Laplacian distribution filter. By some threshold will determine which noise pixels to recover. This is what preprocess_data() does which will return a matrix img containing the loaded image and noise, the image mask where a value of 1 represents a noise pixel.","category":"page"},{"location":"tutorial.html#Solve-the-problem","page":"Tutorial","title":"Solve the problem","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We're going to attempt to recover the missing data by denoising the image through rank minimization. Just like was described in section Using an SDP Model;","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(i) We create a ConeQP object that represents the rank minimization problem to solve cone_qp = denoise_image(img, noise).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(ii) We pass the ConeQP object to the solver solver = Solver(cone_qp).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(iii) Then when we're ready we call optimize! passing the solver object optimize!(solver).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(iv) We can access the solution by accessing the primal solution from the solver x = get_solution(solver).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(v) However because x is the lower triangular part of the SDP matrix we need to index into the matrix to get back our image. This is easily done by calling the function like so output_img = get_X1(sdp, x).","category":"page"},{"location":"tutorial.html#Get-the-solution","page":"Tutorial","title":"Get the solution","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"How do we know we solved the problem? Well, inspecting the output we observe a couple of things:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We obtain a duality gap of zero (or close to zero), this suggests that the solution we obtained is optimal.\nThe x residual r_x, y residual r_y, z residual r_z are close to zero, this means we satisfied the primal and dual feasibility conditions.\nThe residuals, duality gap and objective values do not change much after successive iterations.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"<img src=\"./assets/example.png\" alt=\"drawing\" width=\"400\"/>","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Once primal feasibility is achieved in this particular example, we ensure that pixel values are nonnegative x = 0 and the non noise pixels are preserved Ax = b.","category":"page"},{"location":"tutorial.html#Further-Comments","page":"Tutorial","title":"Further Comments","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Many optimization problems are not easy to solve and solvers including this one can run into numerical stability and performance issues. It is worthwhile exploring different parameter settings and reformulating the problem being solved in the event that these become issues.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"NOTE: We should bound 0 = x = 1 since pixel values shouldn't be larger than one but leave this as an exercise to the reader.","category":"page"}]
}
